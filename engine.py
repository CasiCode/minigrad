# -*- coding: utf-8 -*-
"""engine.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12dFOWHQX6uPcC9860Zl7VaIJAqS5LeSs
"""

import math
import numbers

#all the r-operands need revision since i'm not sure they are safe
class Value:
    def __init__(self, value, _children=(), _operation='') -> None:
        assert isinstance(value, numbers.Number), 'only numeric datatypes are supported'
        self.value = value
        self.grad = 0.0
        self._prev = set(_children)
        self._operation = _operation
        self._backward = None

    def __repr__(self) -> str:
        return f'Value(value={self.value})'

    def __add__(self, rhs):
        rhs = rhs if isinstance(rhs, Value) else Value(rhs)
        out = Value(
            value=self.value+rhs.value,
            _children=(self, rhs),
            _operation='__add__'
        )

        def _backward():
            self.grad += out.grad
            rhs.grad += out.grad
        out._backward = _backward

        return out

    def __radd__(self, rhs):
        return self + rhs

    def __mul__(self, rhs):
        rhs = rhs if isinstance(rhs, Value) else Value(rhs)
        return Value(
            value=self.value*rhs.value,
            _children=(self, rhs),
            _operation='__mul__'
        )

    def __rmul__(self, rhs):
        rhs = rhs if isinstance(rhs, Value) else Value(rhs)
        return Value(
            value=self.value*rhs.value,
            _children=(rhs, self),
            _operation='__rmul__'
        )

    def __neg__(self):
        return Value(
            value=self.value * -1,
            _children=(self, ),
            _operation='__neg__'
        )

    def __sub__(self, rhs):
        assert isinstance(rhs, (numbers.Number, Value)), 'invalid dtype'
        return self + (-rhs)

    def __rsub__(self, rhs):
        return rhs + (-self)

    def __pow__(self, rhs):
        # rising to the power of Value requires a more complex derivative calculation
        # TODO rising to the power of Value
        assert isinstance(rhs, numbers.Number), 'invalid power dtype'
        return Value(
            value=self.value**rhs.value,
            _children=(self, rhs),
            _operation='__pow__'
        )

    def __truediv__(self, rhs):
        rhs = rhs if isinstance(rhs, Value) else Value(rhs)
        return Value(
            value=self.value * (rhs**-1).value,
            _children=(self, rhs),
            _operation='__truediv__'
        )

    def __truediv__(self, rhs):
        rhs = rhs if isinstance(rhs, Value) else Value(rhs)
        return Value(
            value=rhs.value * (self**-1).value,
            _children=(rhs, self),
            _operation='__truediv__'
        )

    def relu(self):
        return Value(
            value=self.value if self.value > 0.0 else 0.0,
            _children=(self, ),
            _operation='relu'
        )